---
title: "ndi_analysis"
author: "Harris Policy Lab"
date: "2/16/2021"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# This code uses dplyr functions released in February 2021, so please update dplyr if you have not done so already.

# List of packages to install
packages <- c("tidyverse", "readxl", "janitor", "reticulate", "countrycode", "Hmisc", "lubridate", "skimr", "haven", "labelled", "scales", "WDI")

# To install the packages, uncomment the line below and run it
#install.packages(packages)

library(tidyverse)
library(readxl)
library(janitor)
library(reticulate)
library(countrycode)
library(Hmisc)
library(lubridate)
library(skimr)
library(haven)
library(labelled)
library(scales)
library(WDI)
```

```{r functions, include=FALSE}

fig_max <- function(x) ifelse( !all(is.na(x)), max(x, na.rm = TRUE), NA)
# Source: https://stackoverflow.com/questions/24519794/r-max-function-ignore-na/24520992

```


```{r importing_and_merging, include=FALSE}

## COVID-19 data from Our World in Data ##
  import_owid_covid_data <- read_csv("data/owid-covid-data.csv", 
                                     col_types = cols(
                                       iso_code = col_character(), 
                                       continent = col_character(), 
                                       location = col_character(), 
                                       date = col_date(format = "%Y-%m-%d"),
                                       tests_units = col_character(),
                                     .default = col_double()))
  
  df_covid_owid <- import_owid_covid_data %>%
    clean_names() %>%
    filter(!iso_code %in% c('OWID_AFR', 'OWID_ASI', 'OWID_EUN', 'OWID_EUR',
                                'OWID_INT', 'OWID_KOS', 'OWID_NAM', 'OWID_NCY',
                                'OWID_OCE', 'OWID_SAM', 'OWID_WRL')) %>%
    mutate(
      country_standard = countrycode(
        iso_code, 
        origin = "iso3c", 
        destination = "country.name"),
      name_country_standard = countryname(location),
      year = year(date)) %>%
    select(country_standard, year, date, name_country_standard, everything())
  
  # Summarizing COVID-19 data by year (previous data frame was daily)
  df_covid_owid_yr <- df_covid_owid %>%
    group_by(country_standard, year) %>%
    # Getting cumulative values for the following variables by year and country
    # These values all begin with "cum_eoy" (cumulative by end of year)
    mutate(
      cum_eoy_total_cases = 
        fig_max(total_cases),
      cum_eoy_total_deaths = 
        fig_max(total_deaths),
      cum_eoy_total_cases_per_million = 
        fig_max(total_cases_per_million),
      cum_eoy_total_deaths_per_million = 
        fig_max(total_deaths_per_million),
      cum_eoy_total_tests = 
        fig_max(total_tests),
      cum_eoy_total_tests_per_thousand = 
        fig_max(total_tests_per_thousand),
      cum_eoy_total_vaccinations = 
        fig_max(total_vaccinations),
      cum_eoy_people_vaccinated = 
        fig_max(people_vaccinated),
      cum_eoy_people_fully_vaccinated = 
        fig_max(people_fully_vaccinated),
      cum_eoy_total_vaccinations_per_hundred = 
        fig_max(total_vaccinations_per_hundred),
      cum_eoy_people_vaccinated_per_hundred = 
        fig_max(people_vaccinated_per_hundred),
      cum_eoy_people_fully_vaccinated_per_hundred = 
        fig_max(people_fully_vaccinated_per_hundred)) %>%
    summarise(across(where(is.numeric), mean, na.rm = TRUE), .groups = "keep") %>%
    ungroup() %>%
    group_by(country_standard) %>%
    arrange(year) %>%
    mutate(
      # Finding amounts per year
      # These values all begin with "annual"
      annual_total_cases = ifelse(
        year == 2020,
        cum_eoy_total_cases,
        cum_eoy_total_cases - lag(cum_eoy_total_cases)),
      annual_total_deaths = ifelse(
        year == 2020,
        cum_eoy_total_deaths,
        cum_eoy_total_deaths - lag(cum_eoy_total_deaths)),
      annual_total_cases_per_million = ifelse(
        year == 2020,
        cum_eoy_total_cases_per_million,
        cum_eoy_total_cases_per_million - lag(cum_eoy_total_cases_per_million)),
      annual_total_deaths_per_million = ifelse(
        year == 2020,
        cum_eoy_total_deaths_per_million,
        cum_eoy_total_deaths_per_million - lag(cum_eoy_total_deaths_per_million)),
      annual_total_tests = ifelse(
        year == 2020,
        cum_eoy_total_tests,
        cum_eoy_total_tests - lag(cum_eoy_total_tests)),
      annual_total_tests_per_thousand = ifelse(
        year == 2020,
        cum_eoy_total_tests_per_thousand,
        cum_eoy_total_tests_per_thousand - lag(cum_eoy_total_tests_per_thousand)),
      annual_total_vaccinations = ifelse(
        year == 2020,
        cum_eoy_total_vaccinations,
        cum_eoy_total_vaccinations - lag(cum_eoy_total_vaccinations)),
      annual_people_vaccinated = ifelse(
        year == 2020,
        cum_eoy_people_vaccinated,
        cum_eoy_people_vaccinated - lag(cum_eoy_people_vaccinated)),
      annual_people_fully_vaccinated = ifelse(
        year == 2020,
        cum_eoy_people_fully_vaccinated,
        cum_eoy_people_fully_vaccinated - lag(cum_eoy_people_fully_vaccinated)),
      annual_total_vaccinations_per_hundred = ifelse(
        year == 2020,
        cum_eoy_total_vaccinations_per_hundred,
        cum_eoy_total_vaccinations_per_hundred - lag(cum_eoy_total_vaccinations_per_hundred)),
      annual_people_vaccinated_per_hundred = ifelse(
        year == 2020,
        cum_eoy_people_vaccinated_per_hundred,
        cum_eoy_people_vaccinated_per_hundred - lag(cum_eoy_people_vaccinated_per_hundred)),
      annual_people_fully_vaccinated_per_hundred = ifelse(
        year == 2020,
        cum_eoy_people_fully_vaccinated_per_hundred,
        cum_eoy_people_fully_vaccinated_per_hundred - lag(cum_eoy_people_fully_vaccinated_per_hundred)),
      # Getting cumulative totals across years
      # These values all begin with "cum"
      cum_total_cases = 
        fig_max(cum_eoy_total_cases),
      cum_total_deaths = 
        fig_max(cum_eoy_total_deaths),
      cum_total_cases_per_million = 
        fig_max(cum_eoy_total_cases_per_million),
      cum_total_deaths_per_million = 
        fig_max(cum_eoy_total_deaths_per_million),
      cum_total_tests = 
        fig_max(cum_eoy_total_tests),
      cum_total_tests_per_thousand = 
        fig_max(cum_eoy_total_tests_per_thousand),
      cum_total_vaccinations = 
        fig_max(cum_eoy_total_vaccinations),
      cum_people_vaccinated = 
        fig_max(cum_eoy_people_vaccinated),
      cum_people_fully_vaccinated = 
        fig_max(cum_eoy_people_fully_vaccinated),
      cum_total_vaccinations_per_hundred = 
        fig_max(cum_eoy_total_vaccinations_per_hundred),
      cum_people_vaccinated_per_hundred = 
        fig_max(cum_eoy_people_vaccinated_per_hundred),
      cum_people_fully_vaccinated_per_hundred = 
        fig_max(cum_eoy_people_fully_vaccinated_per_hundred)    
      ) %>%
    ungroup() %>%
    arrange(country_standard, year)
    
########################################      
  
## Economist Intelligence Unit ##

    # The line below runs an R script that cleans the raw EIU data and 
    #   merges it as the EIU_democracy_index_clean.csv file
    source("data/raw_data/clean_eiu_raw.R", echo =  FALSE)

  import_EIU <- read_csv("data/EIU_democracy_index_clean.csv")
  
  df_eiu <- import_EIU %>%
    clean_names() %>%
    mutate(
      # Countries from 2020 are missing iso codes
      geo =
        ifelse(
          is.na(geo),
          countrycode(country, origin = 'country.name', destination = 'iso3c'),
          geo
          ),
      country_standard = countrycode(
        geo, 
        origin = "iso3c", 
        destination = "country.name"
        )) %>%
    # Adding "eiu" prefix to column names
    rename_with( 
    ~ paste("eiu", .x, sep = "_"), 
    overall_score:date) %>%
    select(country_standard, year, eiu_overall_score:eiu_regime_type, -eiu_rank, -eiu_rank_change)

########################################    
  
## Transparency International Corruption Perception Index
  
  import_CPI_Transparency_International <- read_excel("data/CPI_Transparency_International_rev.xlsx")
  
  df_cpi <- import_CPI_Transparency_International %>%
    clean_names() %>%
    mutate(
      country_standard = countrycode(
        country_code,
        origin = "iso3c",
        destination = "country.name",
        custom_match = c('KSV' = 'Kosovo'))) %>%
    select(country_standard, year, cpi_score)
  
########################################     
      
## Data from Open Government Partnership ##
  
  import_OGP_data <- read_excel("data/OGP_data.xlsx", 
    col_types = c("text", "numeric", "numeric", "numeric", "numeric"), 
    na = "NA")
  
  df_ogp <- import_OGP_data %>%
    clean_names() %>%
    rename(ogp_transparency_fisc_open = ogp_considerations_fo_transparency,
           ogp_participation_fisc_open = ogp_considerations_fo_participation) %>%
    mutate(
      country_standard = countrycode(
        country_code,
        origin = "iso3c",
        destination = "country.name"),
      ogp_trans_text = case_when(
        ogp_transparency_fisc_open == 1 ~ "Consider Action",
        ogp_transparency_fisc_open == 2 ~ "Implement for Results",
        ogp_transparency_fisc_open == 3 ~ "Share Innovation",
        TRUE ~ NA_character_),
      ogp_part_text = case_when(
        ogp_participation_fisc_open == 1 ~ "Consider Action",
        ogp_participation_fisc_open == 2 ~ "Implement for Results",
        ogp_participation_fisc_open == 3 ~ "Share Innovation",
        TRUE ~ NA_character_)      
      ) %>%
    filter(!is.na(country_standard)) %>%
    select(country_standard, everything(), -country_code) %>%
    arrange(country_standard, year)
  
  # Merging with large list of countries in previously saved merged_data_yr 
  # and assigning "zero" values to the ogp_participating variable for countries
  # not included in the imported OGP dataset
  df_ogp <- read_csv("data/merged_data_yr.csv") %>%
    select(country_standard, year) %>%
    distinct() %>%
    full_join(df_ogp, by = c("country_standard", "year")) %>%
    mutate(ogp_participating = ifelse(
      is.na(ogp_participating),
      0,
      ogp_participating
    )) %>%
    arrange(country_standard, year)

########################################    
  
## WGI indicators ##
  
  # Voice & Accountability and Control of Corruption
  
  import_Worldwide_Governance_Indicators_clean <- read_csv("data/Worldwide_Governance_Indicators_clean.csv")
  
  
  # Note: higher score is better for these indicators
  df_wgi <- import_Worldwide_Governance_Indicators_clean %>%
    clean_names() %>%
    rename(country = country_territory) %>%
    # The countrycodes package does not include Kosovo or the Netherlands Antilles
    #filter(!country %in% c("Kosovo", "Netherlands Antilles (former)")) %>%
    mutate(
      country = case_when(
        code == "CIV" ~ "Ivory Coast",
        code == "STP" ~ "Sao Tome and Principe",
        code == "REU" ~ "Reunion",
        TRUE ~ country),
      iso_code = countrycode(country, origin = 'country.name', destination = 'iso3c'),        
      country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"),
      country_standard = ifelse(
        is.na(country_standard),
        country,
        country_standard)) %>%
    # Adding "wgi" prefix to indicators
    rename_with( 
      ~ paste("wgi", .x, sep = "_"),
      voice_and_accountability:control_of_corruption) %>%
    select(country_standard, year, everything(), -x1, -country, -iso_code)

  # Government Effectiveness
  #   Higher values = better
  import_wgi_gov_effective <- read_excel("data/wgi_gov_effective.xlsx", na = "NA")
  
  df_wgi_effect <- import_wgi_gov_effective %>%
    clean_names() %>%
    mutate(
      country_standard = countrycode(
        code,
        origin = "iso3c",
        destination = "country.name")) %>%
    filter(!is.na(country_standard)) %>%
    select(country_standard, everything(), -country_territory, -code) %>%
    pivot_longer(!country_standard, names_to = "year", values_to = "wgi_govt_effective") %>%
    mutate(
      year = as.numeric(
        str_remove(year, "x"))) %>%
    arrange(country_standard, year)
    
########################################    
  
## V-Dem indicators ##
  # There are three V-Dem data sets. We combine the first two.
  
  import_vdem_clean <- read_csv("data/vdem_clean.csv")
  
  df_vdem <- import_vdem_clean %>%
    clean_names() %>%
    # This data set has a very large range of years. Limiting to 2006 and later
    filter(year >= 2006) %>%
    #filter(!country_name %in% c("Kosovo", "Somaliland", "Zanzibar")) %>%  
    mutate(
      iso_code = countrycode(country_name, origin = 'country.name', destination = 'iso3c'),        
      country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"),
      # Lines below are to address three countries that get left out: 
      #     Kosovo, Somaliland, Zanzibar
      country_standard = ifelse(
        is.na(country_standard),
        country_name,
        country_standard)) %>%
    # Adding "vdem" prefix to indicators      
    rename_with( 
      ~ paste("vdem", .x, sep = "_"),
      v2x_libdem:v2x_cspart) %>%
    select(country_standard, year, everything(), -country_name, -iso_code)
  
  # Additional V-Dem indicators for accountability, transparency, and corruption
    # Note: Higher score is better for these indicators
  import_vdem_atc <- read_csv("data/Vdem_account_transp_corrupt.csv")
  
  df_vdem_atc <- import_vdem_atc %>%
    clean_names() %>%
    # This data set has a very large range of years. Limiting to 2006 and later
    filter(year >= 2006) %>%
    #filter(!country_name %in% c("Kosovo", "Somaliland", "Zanzibar")) %>%  
    mutate(
      iso_code = countrycode(country_name, origin = 'country.name', destination = 'iso3c'),        
      country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"),
      # Lines below are to address ountries that get left out by "countrycode" function
      country_standard = ifelse(
        is.na(country_standard),
        country_name,
        country_standard)) %>%
    # Adding "vdem" prefix to indicators      
    rename_with( 
      ~ paste("vdem", .x, sep = "_"),
      transparent_laws:public_sector_corruption) %>%
    select(country_standard, year, everything(), -country_name, -country_text_id)
  
  df_vdem <- df_vdem %>% full_join(df_vdem_atc, by = c("country_standard", "year"))
  
  # Data from V-Dem's "Pandemic Backsliding" Project
  import_pandem <- read_csv("data/PanDem_cs_V5.csv")
  
  df_pandem <- import_pandem  %>%
    clean_names() %>%
    mutate(
      iso_code = countrycode(country_name, origin = 'country.name', destination = 'iso3c'),        
      country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"
          )) %>%
    select(country_standard, pandem, panback) %>%
    distinct()
  
########################################    
  
## Freedom House indicators ##
  import_Freedom_house  <- read_csv("data/Freedom_house_rev.csv")
  
  # Note: the higher the freedom score, the better
  df_fh <- import_Freedom_house %>%
    clean_names() %>%
    mutate(
      iso_code = countrycode(
        countries, 
        origin = 'country.name', 
        destination = 'iso3c', 
        custom_match = c('Micronesia' = 'FSM')),        
      country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"),
      country_standard = ifelse(
        is.na(country_standard),
        countries,
        country_standard),
      # Lines below are to address countries that get left out by "countrycode" function
      country_standard = ifelse(
        is.na(country_standard),
        countries,
        country_standard)) %>%
    rename(fh_global_freedom_score = global_freedom_score) %>%
    select(country_standard, year, fh_global_freedom_score) %>%
    arrange(country_standard, year)

########################################    
  
## WVS indicators ##
  
  # The data imported in the line below is too large to store on GitHub.
  # It can be stored locally and downloaded from this link: 
  #     https://www.worldvaluessurvey.org/WVSDocumentationWVL.jsp
  import_wvs <- readRDS("~/GitHub/policy_lab_ndi/data/WVS_TimeSeries_R_v1_6.rds")
  
  df_wvs <- import_wvs %>%
    select(S003, S020, E069_07, E069_11, E069_17, E069_64, E268) %>%
    mutate(
      country_standard = countrycode(
        S003, 
        origin = "iso3n", 
        destination = "country.name")
    ) %>%
    rename(
      year = S020,
      wvs_trust_parliament = E069_07,
      wvs_trust_gov = E069_11,
      wvs_trust_court = E069_17,
      wvs_trust_elect = E069_64,
      wvs_corruption = E268
    ) %>%
    select(country_standard, everything(), -S003) 

  
  # WVS data uses labels. The line below can be useful for seeing
  # the value-label association
  # val_labels(df_wvs)
  
  df_wvs <- df_wvs %>%
    mutate(
      across(year:wvs_corruption, ~as.numeric(.)),
      across(year:wvs_corruption, ~replace(., is.na(.), NA_integer_)),
        # WVS uses a counter-intuitive scoring system (higher number = worse)
        # The code below reverses this for variables measured from 1 to 4
      across(wvs_trust_parliament:wvs_trust_elect, ~5-.),
        # The code below reverses this for variables measured from 1 to 10)
      wvs_corruption = 11 - wvs_corruption) %>%
      group_by(country_standard, year) %>%
        # Creating averages by country and year
      summarise(across(wvs_trust_parliament:wvs_corruption, ~mean(.x, na.rm = TRUE)), .groups = "drop") %>%
        # Changing NaN to NA
      mutate(across(year:wvs_corruption, ~ case_when(!is.nan(.x) ~ .x))) %>%
      arrange(country_standard, year) %>%
    filter(year >= 2006)
      
########################################      
    
## Africa Integrity Indicators ##
  
  import_africa_integrity <- read_excel("data/Africa_Integrity_Indictors_CLEAN_22021.xlsx", na = "n/a")
  
  df_africa_int <- import_africa_integrity %>%
    clean_names()  %>% 
    select(
      country,
      year,
      in_practice_citizens_can_access_the_results_and_documents_associated_with_procurement_contracts_full_contract_proposals_execution_reports_financial_audits_etc,
      in_law_citizens_have_a_right_to_request_public_information_from_state_bodies,
      in_practice_citizen_requests_for_public_information_are_effective,
      in_practice_citizens_can_access_legislative_processes_and_documents,
      in_law_senior_officials_of_the_three_branches_of_government_including_heads_of_state_and_government_ministers_members_of_parliament_judges_etc_are_required_to_disclose_records_of_their_assets_and_disclosures_are_public,
      in_law_political_parties_are_required_to_regularly_disclose_private_donations,
      in_law_corruption_is_criminalized_as_a_specific_offense,
      in_practice_the_body_bodies_that_investigate_s_allegations_of_public_sector_corruption_is_are_effective,
      in_law_civil_servants_who_report_cases_of_corruption_are_protected_from_recrimination_or_other_negative_consequences,
      in_law_there_is_an_independent_body_bodies_mandated_to_receive_and_investigate_cases_of_alleged_public_sector_corruption
    )
  
  names(df_africa_int) <- names(df_africa_int) %>% 
    str_remove("^in_practice_") %>% 
    str_remove("^in_law_") %>% 
    str_trunc(32,  ellipsis = "")
    
  names(df_africa_int) <- names(df_africa_int) %>% make.unique()
  
  df_africa_int <- df_africa_int %>%
    mutate(
      country = ifelse(
        country == "sundan",
        "sudan",
        country),
      iso_code = countrycode(country, origin = 'country.name', destination = 'iso3c'),
      country_standard = countrycode(
        iso_code, 
        origin = "iso3c", 
        destination = "country.name"
        )) %>%
    select(country_standard, year, everything(), -country) %>%    
    # Adding "afr_int" prefix to column names
    rename_with( 
    ~ paste("afr_int", .x, sep = "_"), 
    !(country_standard:year)) %>%
    filter(!is.na(year))
  
########################################    
    
## World Bank Data from WDI package for control variable options
#    Public health expenditures per capita , GDP, Gini Coefficient, 
#    and GDP Per Capita
  
  
## Public health expenditures per capita ##
  
#    At time of import, data was only available to 2018
#   Including the Purchasing Power Parity adjustment as well  
  import_percap_Public_Health_Expenditure <- WDI(indicator = c('SH.XPD.GHED.PC.CD', 'SH.XPD.GHED.PP.CD'), start = 2006)
  
  df_percap_health_expend <- import_percap_Public_Health_Expenditure %>% 
    clean_names() %>%
    mutate(
        country_standard = countrycode(
          iso2c, 
          origin = "iso2c", 
          destination = "country.name",
          custom_match = c('XK' = 'Kosovo'))) %>% 
    rename(
      percap_domestic_health_expenditure = sh_xpd_ghed_pc_cd,
      percap_domestic_health_expenditure_ppp = sh_xpd_ghed_pp_cd) %>%
    filter(!is.na(country_standard)) %>%
    select(country_standard, year, percap_domestic_health_expenditure, percap_domestic_health_expenditure_ppp)
  
  
## GDP Data ##
  
  # At time of import, data was only available to 2019
  import_GDP_data <- WDI(indicator = 'NY.GDP.MKTP.CD', start = 2006)
  
  df_gdp <- import_GDP_data %>% 
    clean_names() %>%
    mutate(
        country_standard = countrycode(
          iso2c, 
          origin = "iso2c", 
          destination = "country.name",
          custom_match = c('XK' = 'Kosovo'))) %>% 
    rename(gdp = ny_gdp_mktp_cd) %>%
    filter(!is.na(country_standard)) %>%
    select(country_standard, year, gdp)
    
  
## Gini Coefficient ##
  
  # At time of import, data was only available to 2018
  import_Gini_coefficient <- WDI(indicator = 'SI.POV.GINI', start = 2006)
  
  df_gini <- import_Gini_coefficient %>%
    clean_names() %>%
      mutate(
        country_standard = countrycode(
          iso2c, 
          origin = "iso2c", 
          destination = "country.name",
          custom_match = c('XK' = 'Kosovo')
          )) %>%
    rename(gini = si_pov_gini) %>%
    filter(!is.na(country_standard)) %>%
    select(country_standard, year, gini)
  
  
## GDP Per Capita ##
  
  # We're using GDP Per Capita as a control variable
  #   We are using GDP Per Capita in current international $
  #   Including the Purchasing Power Parity adjustment as well
  import_gdp_percap <- WDI(indicator = c('NY.GDP.PCAP.CD', 'NY.GDP.PCAP.PP.CD'), start = 2006)
  
  df_gdp_percap <- import_gdp_percap %>%
    clean_names() %>%
      mutate(
        country_standard = countrycode(
          iso2c, 
          origin = "iso2c", 
          destination = "country.name",
          custom_match = c('XK' = 'Kosovo')
          )) %>%
    rename(
      gdp_percap_ppp = ny_gdp_pcap_pp_cd,
      gdp_percap = ny_gdp_pcap_cd) %>%
    # Line below is for non-PPP GDP per capita
    # rename(gdp_percap = ny_gdp_pcap_cd) %>%
    filter(!is.na(country_standard)) %>%
    select(country_standard, year, gdp_percap, gdp_percap_ppp) %>%
    filter(year<=2019) #No 2020 data at time of accessing data
  
```


Merging datasets

```{r merging_data, include=FALSE}
  df_all <- df_covid_owid %>%
    full_join(df_eiu, by = c("country_standard", "year")) %>%
    full_join(df_cpi, by = c("country_standard", "year")) %>%
    full_join(df_ogp, by = c("country_standard", "year")) %>%  
    full_join(df_wgi, by = c("country_standard", "year")) %>% 
    full_join(df_wgi_effect, by = c("country_standard", "year")) %>%
    full_join(df_vdem, by = c("country_standard", "year")) %>% 
    full_join(df_pandem, by = "country_standard") %>%      
    full_join(df_fh, by = c("country_standard", "year")) %>%       
    full_join(df_percap_health_expend, by = c("country_standard", "year")) %>%
    full_join(df_gdp, by = c("country_standard", "year")) %>%
    full_join(df_gini, by = c("country_standard", "year")) %>%
    full_join(df_gdp_percap, by = c("country_standard", "year")) %>%
    full_join(df_wvs, by = c("country_standard", "year")) %>%
    full_join(df_africa_int, by = c("country_standard", "year")) %>%
    select(
      country_standard, 
      year, 
      date,
      everything(),
      -name_country_standard,
      -location,
      -gdp_per_capita # We import separate GDP per cap directly from WB,
      ) %>%
    mutate(post_covid = 
             ifelse(year >= 2020,
                    TRUE,
                    FALSE))

  # Looking at entries where ISO codes didn't match with a country
  df_no_country <- df_all %>% filter((is.na(country_standard)))
  
  # Removing entries with missing country_standard name
  df_all <- df_all %>% filter(!(is.na(country_standard)))
  
  # Limiting to the year 2006 and later
  df_all <- df_all %>% filter(year >= 2006)

  # Exporting df_all
  write_csv(df_all, "data/merged_data.csv")
  
  ## By year instead of date ##
  df_all_yr <- df_covid_owid_yr %>%
    full_join(df_eiu, by = c("country_standard", "year")) %>%
    full_join(df_cpi, by = c("country_standard", "year")) %>%
    full_join(df_ogp, by = c("country_standard", "year")) %>%  
    full_join(df_wgi, by = c("country_standard", "year"))  %>% 
    full_join(df_wgi_effect, by = c("country_standard", "year")) %>%
    full_join(df_vdem, by = c("country_standard", "year")) %>% 
    full_join(df_pandem, by = "country_standard") %>%      
    full_join(df_fh, by = c("country_standard", "year")) %>%       
    full_join(df_percap_health_expend, by = c("country_standard", "year")) %>%
    full_join(df_gdp, by = c("country_standard", "year")) %>%
    full_join(df_gdp_percap, by = c("country_standard", "year")) %>%
    full_join(df_gini, by = c("country_standard", "year")) %>%
    full_join(df_wvs, by = c("country_standard", "year")) %>%    
    full_join(df_africa_int, by = c("country_standard", "year")) %>%
    select(
      country_standard, 
      year, 
      everything(),
      -gdp_per_capita # We import separate GDP per cap directly from WB
      ) %>%
    mutate(post_covid = 
             ifelse(year >= 2020,
                    TRUE,
                    FALSE))
  
    # Limiting to the year 2006 and later
          # Some data (including WGI and Gini index) go back further
    df_all_yr <- df_all_yr %>% filter(year >= 2006)
    
    # Looking specifically at 2020
    df_all_yr_2020 <- df_all_yr %>% filter(year == 2020)
  
    # Exporting df_all_yr
    write_csv(df_all_yr, "data/merged_data_yr.csv")
    write_csv(df_all_yr_2020, "data/merged_data_yr_2020.csv")
  
```

When reviewing the data, a helpful link for issues: https://github.com/ropensci/skimr/issues/606

```{r controls, echo=TRUE}

# Controls for COVID outcomes
df_controls <- df_all_yr %>%
  arrange(country_standard, year) %>%
  group_by(country_standard) %>%
  # These variables don't have values in 2020. Filling in from most recent year
  fill(
    c(gdp, gini, 
      percap_domestic_health_expenditure, percap_domestic_health_expenditure_ppp,
      gdp_percap, gdp_percap_ppp)) %>%
  filter(year==2020) %>%
  rename(gdp_percap_ppp_covid = gdp_percap_ppp) %>%
  select(
    country_standard, 
    gdp,
    gini,
    gdp_percap,
    gdp_percap_ppp_covid,
    percap_domestic_health_expenditure,
    percap_domestic_health_expenditure_ppp)
  
df_controls <- df_all_yr_2020 %>%
  select(
    country_standard, median_age, aged_65_older) %>%
  full_join(df_controls, by = "country_standard") %>% 
  mutate(across(median_age:aged_65_older, ~ case_when(!is.nan(.x) ~ .x))) %>%
  select(
    country_standard, gdp, gini, gdp_percap, gdp_percap_ppp_covid,
    percap_domestic_health_expenditure, percap_domestic_health_expenditure_ppp,
    median_age, aged_65_older) %>% 
  # Removing rows with all NA values
  filter(if_any(gdp:aged_65_older, ~ !is.na(.)))

write_csv(df_controls, "data/controls.csv")

```


# Creating an index for COVID-19 health factors

(add that we are logging)

Our COVID-19 index comes from country-level measures starting from January 1, 2020. The measures are used in the following equation: (1 / COVID-19 cases per million) * (1 / COVID-19 deaths per million) * (total COVID-19 tests per thousand)

The intuition is that countries will have a higher index score if they have fewer cases, fewer deaths, and more tests. The index is scaled from 0 (worst) to 1 (best).

We decided on this index after testing it among six considered models. We regressed each index on our list of control variables and compared the F-statistic of each model. The chosen model had the second highest F-Statistic, but was chosen because a review of the country rankings of the model with the highest F-statistic revealed it to be a poor index.

To see the code for the process above, see reference_dode/covid_index_select.r

For countries that were missing data on COVID-19 tests, they are assigned a score of "1" on the scale of 1 to 10 used for countries' testing rates.

```{r covid_index, echo=TRUE}
df_covid_index <- df_all_yr %>%
  select(
    country_standard, 
    cum_total_cases_per_million, 
    cum_total_deaths_per_million,
    cum_total_tests_per_thousand) %>%
  # Removing rows with all NA values
  filter(
    if_any(
      cum_total_cases_per_million:cum_total_deaths_per_million, 
      ~ !is.na(.))) %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
        # Use a scale of 1 - 10 to avoid having "0" in denominator
        # Not that we use a natural log on the three lines below
    stand_total_cases_per_million  = rescale(log(cum_total_cases_per_million), to = c(1, 10)),
    stand_total_deaths_per_million = rescale(log(cum_total_deaths_per_million), to = c(1, 10)),
    stand_total_tests_per_thousand = rescale(log(cum_total_tests_per_thousand), to = c(1, 10)),
    non_na_sum = rowSums(!is.na(across(cum_total_cases_per_million:cum_total_tests_per_thousand))),
    stand_total_tests_per_thousand_no_NA = ifelse(
      is.na(stand_total_tests_per_thousand), 
      1, 
      stand_total_tests_per_thousand),
    covid_index = rescale(
      (1/stand_total_cases_per_million) +
      (1/stand_total_deaths_per_million) +
      stand_total_tests_per_thousand_no_NA),
    incomplete_covid_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE)    
    ) %>%
  select(country_standard, covid_index, everything()) %>%
  filter(!is.na(covid_index))

# Reviewing distribution of the data
histogram(df_covid_index$stand_total_cases_per_million)
histogram(df_covid_index$stand_total_deaths_per_million)
histogram(df_covid_index$stand_total_tests_per_thousand_no_NA)
histogram(df_covid_index$covid_index)

# RUnning a regression of control variables on COVID-19 index
covid_index_mod_test <- df_covid_index %>% 
  select(country_standard, covid_index) %>%
  full_join(df_controls, by = "country_standard") %>%
  select(-country_standard)

  lm(covid_index ~ ., data = covid_index_mod_test) %>% summary()

write_csv(df_covid_index, "data/covid-19_index.csv")

```

# Transparency Index

```{r}
df_transparency_indicators <- df_all_yr %>%
  select(
    country_standard,
    year,
    fh_global_freedom_score,
    wgi_voice_and_accountability
  ) 

df_transparency_index <- df_transparency_indicators %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
    non_na_sum = rowSums(!is.na(across(fh_global_freedom_score:wgi_voice_and_accountability))),
    across(
      fh_global_freedom_score:wgi_voice_and_accountability,
      ~rescale(.)),
    numerator = rowSums(across(fh_global_freedom_score:wgi_voice_and_accountability), na.rm=TRUE),
    transparency_index = rescale(numerator / non_na_sum),
    incomplete_trans_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE
    )) %>%
  select(country_standard, year, transparency_index, everything()) %>%
  arrange(country_standard, year) %>%
  # The line below only keeps transparency index entries 
  filter(!is.na(fh_global_freedom_score) & !is.na(wgi_voice_and_accountability)) %>%
  filter(year <= 2019)

skim(df_transparency_index)
histogram(df_transparency_index$transparency_index)
```
# Budget transparency index

```{r}
# I assign "0" to NA values (assuming that means countries not participating)

country_list <- read_csv("data/country_list.csv")

df_budget_transparency_index <- df_all_yr %>% 
  filter(year == 2019) %>%
  select(
    country_standard,
    ogp_transparency_fisc_open) %>%
  full_join(country_list, by = "country_standard") %>%
  filter(!is.na(country_standard)) %>%
  distinct() %>%
  mutate(
    ogp_transparency_fisc_open = ifelse(
      is.na(ogp_transparency_fisc_open),
      0,
      ogp_transparency_fisc_open),
    incomplete_bdgt_trans_index = if_else(
      ogp_transparency_fisc_open==0,
      TRUE,
      FALSE),
    budget_transparency_index = rescale(ogp_transparency_fisc_open)) %>%
  select(country_standard, budget_transparency_index, everything()) %>%
  arrange(country_standard)

skim(df_budget_transparency_index)
histogram(df_budget_transparency_index$budget_transparency_index)
```

# Accountability Index

```{r}

#   The most recent data in the index is from 2019

df_accountability_indicators <- df_all_yr %>%
  select(
    country_standard,
    year,
    vdem_diagonal_account,
    vdem_vertical_account,
    vdem_horizontal_account
  ) %>%
  # Removing rows with all NA values
  filter(
    if_any(
      vdem_diagonal_account:vdem_horizontal_account, 
      ~ !is.na(.)))

df_accountability_index <- df_accountability_indicators %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
    non_na_sum = rowSums(!is.na(across(vdem_diagonal_account:vdem_horizontal_account))),
    across(
      vdem_diagonal_account:vdem_horizontal_account,
      ~rescale(.)),
    numerator = rowSums(across(vdem_diagonal_account:vdem_horizontal_account), na.rm=TRUE),
    accountability_index = rescale(numerator / non_na_sum),
    incomplete_acnt_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE)) %>%
  select(country_standard, year, accountability_index, everything()) %>%
  arrange(country_standard, year)

skim(df_accountability_index)
histogram(df_accountability_index$accountability_index)
```


# Trust index

```{r}
# NDI seemed interested in "Democratic Political Culture" (This seems to have more to do with the perception of democracy and not trust of government)
#   Leaving out for now

df_trust_indicators <- df_all_yr %>%
  select(
    country_standard,
    year,
    wvs_trust_parliament,
    #eiu_pol_culture,
    wvs_trust_gov,
    wvs_trust_court,
    wvs_trust_elect) %>%
  # Removing rows with all NA values
  filter(
    if_any(
      wvs_trust_parliament:wvs_trust_elect, 
      ~ !is.na(.)))

df_trust_index <- df_trust_indicators %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
    non_na_sum = rowSums(!is.na(across(wvs_trust_parliament:wvs_trust_elect))),
    across(
      wvs_trust_parliament:wvs_trust_elect,
      ~rescale(.)),
    numerator = rowSums(across(wvs_trust_parliament:wvs_trust_elect), na.rm=TRUE),
    trust_index = rescale(numerator / non_na_sum),
    incomplete_trust_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE)) %>%    
  select(country_standard, year, trust_index, everything()) %>%
  arrange(country_standard, year)

countries_in_trust_index <- df_trust_index %>% filter(!is.na(trust_index)) %>% select(country_standard, year) %>% distinct() %>% tibble()

skim(df_trust_index)
histogram(df_trust_index$trust_index)
```

# Corruption index

```{r}

# We have option to include WVS corruption indicator, but it is not very comprehensive
# Even though CPI has 2020 data, limiting to 2019 or earlier to avoid
#   perception of a big shock

df_corruption_indicators <- df_all_yr %>%
  select(
    country_standard,
    year,
    wgi_control_of_corruption,
    #wvs_corruption,
    cpi_score) %>%
  arrange(country_standard, year) %>%
  # Removing rows with all NA values
  filter(
    if_any(
      wgi_control_of_corruption:cpi_score, 
      ~ !is.na(.)))

df_corruption_index <- df_corruption_indicators %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
    non_na_sum = rowSums(!is.na(across(wgi_control_of_corruption:cpi_score))),
    across(
      wgi_control_of_corruption:cpi_score,
      ~rescale(.)),
    numerator = rowSums(across(wgi_control_of_corruption:cpi_score), na.rm=TRUE),
    corruption_index = rescale(-(numerator / non_na_sum)),
    incomplete_corrupt_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE)) %>%    
  select(country_standard, year, corruption_index, everything()) %>%
  arrange(country_standard, year) %>%
  #filter(!is.na(cpi_score) & !is.na(wgi_control_of_corruption)) %>%
  filter(year <= 2019)

skim(df_corruption_index)
histogram(df_corruption_index$corruption_index)
```
# Effectiveness Index

```{r}
# Even though EIU has 2020 data, limiting to 2019 or earlier to avoid
#   perception of a big shock

df_effectiveness_indicators <- df_all_yr %>%
  select(
    country_standard,
    year,
    wgi_govt_effective,
    eiu_gov_func) %>%
  # Removing rows with all NA values
  filter(
    if_any(
      wgi_govt_effective:eiu_gov_func, 
      ~ !is.na(.)))

df_effectiveness_index <- df_effectiveness_indicators %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
    non_na_sum = rowSums(!is.na(across(wgi_govt_effective:eiu_gov_func))),
    across(
      wgi_govt_effective:eiu_gov_func,
      ~rescale(.)),
    numerator = rowSums(across(wgi_govt_effective:eiu_gov_func), na.rm=TRUE),
    effectiveness_index = rescale(numerator / non_na_sum),
    incomplete_effect_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE)) %>%
  select(country_standard, year, effectiveness_index, everything()) %>%
  arrange(country_standard, year) %>%
  # Most of these are small, island countries. Notably Somalia is dropped. 
  #filter(!is.na(wgi_govt_effective) & !is.na(eiu_gov_func)) %>%
  filter(year <= 2019)

skim(df_effectiveness_index)
histogram(df_effectiveness_index$effectiveness_index)

```

# Budget particpation index

```{r}
# I assign "0" to NA values (assuming that means countries not participating)

df_budget_particpation_index <- df_all_yr %>%
  filter(year == 2019) %>%
  select(
    country_standard,
    ogp_participation_fisc_open) %>% 
  full_join(country_list, by = "country_standard") %>%
  filter(!is.na(country_standard)) %>%
  distinct() %>%
  mutate(
    ogp_participation_fisc_open = ifelse(
      is.na(ogp_participation_fisc_open),
      0,
      ogp_participation_fisc_open),
    incomplete_bdgt_part_index = if_else(
      ogp_participation_fisc_open==0,
      TRUE,
      FALSE),
    budget_participation_index = rescale(ogp_participation_fisc_open)) %>%
  select(country_standard, budget_participation_index, everything()) %>%
  arrange(country_standard)

skim(df_budget_particpation_index)
histogram(df_budget_particpation_index$budget_participation_index)

```

# Pandemic Violation Index

```{r}
df_pandem_dem_violation_index <- df_all_yr %>%
  select(
    country_standard,
    pandem
  ) %>%
  filter(!is.na(country_standard)) %>%
  distinct() %>%
  mutate(
    incomplete_dem_vio_index = if_else(
      is.na(pandem),
      TRUE,
      FALSE),    
    pandemic_dem_violation_index = rescale(pandem)) %>%
  select(country_standard, pandemic_dem_violation_index, everything()) %>%
  arrange(country_standard)

skim(df_pandem_dem_violation_index)
histogram(df_pandem_dem_violation_index$pandemic_dem_violation_index)

```

# Combining Indices and Controls

```{r}

df_indices_controls <- df_transparency_index %>%
  select(country_standard, year, transparency_index, incomplete_trans_index) %>%
  full_join(df_accountability_index[ , c("country_standard", "year", "accountability_index", "incomplete_acnt_index")], by = c("country_standard", "year")) %>%
  full_join(df_trust_index[ , c("country_standard", "year", "trust_index", "incomplete_trust_index")], by = c("country_standard", "year")) %>%
  full_join(df_corruption_index[ , c("country_standard", "year", "corruption_index", "incomplete_corrupt_index")], by = c("country_standard", "year")) %>%
  full_join(df_effectiveness_index[ , c("country_standard", "year", "effectiveness_index", "incomplete_effect_index")], by = c("country_standard", "year")) %>%
  full_join(df_budget_particpation_index[ , c("country_standard", "budget_participation_index", "incomplete_bdgt_part_index")], by = "country_standard") %>%
  full_join(df_budget_transparency_index[ , c("country_standard", "budget_transparency_index", "incomplete_bdgt_trans_index")], by = "country_standard") %>%
  full_join(df_pandem_dem_violation_index[ , c("country_standard", "pandemic_dem_violation_index", "incomplete_dem_vio_index")], by = "country_standard") %>%
  full_join(df_covid_index[ , c("country_standard", "covid_index", 'incomplete_covid_index')], by = "country_standard") %>%
  full_join(df_controls, by = "country_standard") %>%
  full_join(df_gdp_percap[ , c("country_standard", "year", "gdp_percap_ppp")], by = c("country_standard", "year")) %>%
  filter(!is.na(country_standard)) %>%
  filter(!is.na(year)) %>%
  arrange(country_standard, year)


df_indices_controls_incomplete <- df_indices_controls %>%
  select(country_standard, year, starts_with('incomplete')) %>%
  replace(is.na(.), TRUE)

df_indices_controls_incomplete_summary <- df_indices_controls_incomplete %>%
  summarise(across(where(is.logical), sum))

df_indices_controls <- df_indices_controls %>% 
  select(country_standard, year, everything(), -starts_with('incomplete')) %>%
  mutate(across(where(is.numeric), ~ case_when(!is.nan(.x) ~ .x)))

skim(df_indices_controls)

write_csv(df_indices_controls, "data/indices_and_controls.csv")

df_indices_mean <- df_indices_controls %>% 
  select(country_standard:covid_index, - year) %>%
  group_by(country_standard) %>%
  summarise(across(transparency_index:covid_index, ~mean(.x, na.rm = TRUE), .names = "mean_{.col}"))
  
write_csv(df_indices_mean, "data/country_average_indices.csv")

```



You can do python code, like in example chunk below.


```

## Notes to self:

We don't have 2020 GDP data

There are about 20 countries missing Gini index data

From OWID Covid, look at "stringeny_index"

Is it an issue that controls don't change by year?

should we make a "most recent" that just pulls the most recent value availalbe for each



freedom house includes 2020 data? I don't see it right now


Additional ideas for controls:

-   df_covid_owid

    -   "population_density"

    -   "gdp_per_capita"

    -   "extreme_poverty"

    -   "cardiovasc_death_rate"

    -   "diabetes_prevalence"

    -   "female_smokers"

    -   "male_smokers"

    -   "handwashing_facilities"

    -   "hospital_beds_per_thousand"

    -   "life_expectancy"

    -   "human_development_index"

## Resources:

-   

## Citations:

This project uses the countrycode R package

Arel-Bundock, Vincent, Nils Enevoldsen, and CJ Yetman, (2018). countrycode: An R package to convert country names and country codes. Journal of Open Source Software, 3(28), 848, <https://doi.org/10.21105/joss.00848>
