---
title: "ndi_analysis"
author: "Harris Policy Lab"
date: "2/16/2021"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# This code uses dplyr functions released in February 2021, so please update dplyr if you have not done so already.

# List of packages to install
packages <- c("tidyverse", "readxl", "janitor", "reticulate", "countrycode", "Hmisc", "lubridate", "skimr", "haven", "labelled", "scales")

# To install the packages, uncomment the line below and run it
#install.packages(packages)

library(tidyverse)
library(readxl)
library(janitor)
library(reticulate)
library(countrycode)
library(Hmisc)
library(lubridate)
library(skimr)
library(haven)
library(labelled)
library(scales)
```

```{r functions, include=FALSE}

fig_max <- function(x) ifelse( !all(is.na(x)), max(x, na.rm = TRUE), NA)
# Source: https://stackoverflow.com/questions/24519794/r-max-function-ignore-na/24520992

```


```{r importing_and_merging, include=FALSE}

## COVID-19 data from Our World in Data ##
  import_owid_covid_data <- read_csv("data/owid-covid-data.csv", 
                                     col_types = cols(
                                       iso_code = col_character(), 
                                       continent = col_character(), 
                                       location = col_character(), 
                                       date = col_date(format = "%m/%d/%Y"),
                                       tests_units = col_character(),
                                     .default = col_double()))
  
  df_covid_owid <- import_owid_covid_data %>%
    clean_names() %>%
    filter(!iso_code %in% c('OWID_AFR', 'OWID_ASI', 'OWID_EUN', 'OWID_EUR',
                                'OWID_INT', 'OWID_KOS', 'OWID_NAM', 'OWID_NCY',
                                'OWID_OCE', 'OWID_SAM', 'OWID_WRL')) %>%
    mutate(
      country_standard = countrycode(
        iso_code, 
        origin = "iso3c", 
        destination = "country.name"),
      name_country_standard = countryname(location),
      year = year(date)) %>%
    select(country_standard, year, date, name_country_standard, everything())
  
  # Summarizing COVID-19 data by year (previous data frame was daily)
  df_covid_owid_yr <- df_covid_owid %>%
    group_by(country_standard, year) %>%
    # Getting cumulative values for the following variables by year and country
    # These values all begin with "cum_eoy" (cumulative by end of year)
    mutate(
      cum_eoy_total_cases = 
        fig_max(total_cases),
      cum_eoy_total_deaths = 
        fig_max(total_deaths),
      cum_eoy_total_cases_per_million = 
        fig_max(total_cases_per_million),
      cum_eoy_total_deaths_per_million = 
        fig_max(total_deaths_per_million),
      cum_eoy_total_tests = 
        fig_max(total_tests),
      cum_eoy_total_tests_per_thousand = 
        fig_max(total_tests_per_thousand),
      cum_eoy_total_vaccinations = 
        fig_max(total_vaccinations),
      cum_eoy_people_vaccinated = 
        fig_max(people_vaccinated),
      cum_eoy_people_fully_vaccinated = 
        fig_max(people_fully_vaccinated),
      cum_eoy_total_vaccinations_per_hundred = 
        fig_max(total_vaccinations_per_hundred),
      cum_eoy_people_vaccinated_per_hundred = 
        fig_max(people_vaccinated_per_hundred),
      cum_eoy_people_fully_vaccinated_per_hundred = 
        fig_max(people_fully_vaccinated_per_hundred)) %>%
    summarise(across(where(is.numeric), mean, na.rm = TRUE), .groups = "keep") %>%
    ungroup() %>%
    group_by(country_standard) %>%
    arrange(year) %>%
    mutate(
      # Finding amounts per year
      # These values all begin with "annual"
      annual_total_cases = ifelse(
        year == 2020,
        cum_eoy_total_cases,
        cum_eoy_total_cases - lag(cum_eoy_total_cases)),
      annual_total_deaths = ifelse(
        year == 2020,
        cum_eoy_total_deaths,
        cum_eoy_total_deaths - lag(cum_eoy_total_deaths)),
      annual_total_cases_per_million = ifelse(
        year == 2020,
        cum_eoy_total_cases_per_million,
        cum_eoy_total_cases_per_million - lag(cum_eoy_total_cases_per_million)),
      annual_total_deaths_per_million = ifelse(
        year == 2020,
        cum_eoy_total_deaths_per_million,
        cum_eoy_total_deaths_per_million - lag(cum_eoy_total_deaths_per_million)),
      annual_total_tests = ifelse(
        year == 2020,
        cum_eoy_total_tests,
        cum_eoy_total_tests - lag(cum_eoy_total_tests)),
      annual_total_tests_per_thousand = ifelse(
        year == 2020,
        cum_eoy_total_tests_per_thousand,
        cum_eoy_total_tests_per_thousand - lag(cum_eoy_total_tests_per_thousand)),
      annual_total_vaccinations = ifelse(
        year == 2020,
        cum_eoy_total_vaccinations,
        cum_eoy_total_vaccinations - lag(cum_eoy_total_vaccinations)),
      annual_people_vaccinated = ifelse(
        year == 2020,
        cum_eoy_people_vaccinated,
        cum_eoy_people_vaccinated - lag(cum_eoy_people_vaccinated)),
      annual_people_fully_vaccinated = ifelse(
        year == 2020,
        cum_eoy_people_fully_vaccinated,
        cum_eoy_people_fully_vaccinated - lag(cum_eoy_people_fully_vaccinated)),
      annual_total_vaccinations_per_hundred = ifelse(
        year == 2020,
        cum_eoy_total_vaccinations_per_hundred,
        cum_eoy_total_vaccinations_per_hundred - lag(cum_eoy_total_vaccinations_per_hundred)),
      annual_people_vaccinated_per_hundred = ifelse(
        year == 2020,
        cum_eoy_people_vaccinated_per_hundred,
        cum_eoy_people_vaccinated_per_hundred - lag(cum_eoy_people_vaccinated_per_hundred)),
      annual_people_fully_vaccinated_per_hundred = ifelse(
        year == 2020,
        cum_eoy_people_fully_vaccinated_per_hundred,
        cum_eoy_people_fully_vaccinated_per_hundred - lag(cum_eoy_people_fully_vaccinated_per_hundred)),
      # Getting cumulative totals across years
      # These values all begin with "cum"
      cum_total_cases = 
        fig_max(cum_eoy_total_cases),
      cum_total_deaths = 
        fig_max(cum_eoy_total_deaths),
      cum_total_cases_per_million = 
        fig_max(cum_eoy_total_cases_per_million),
      cum_total_deaths_per_million = 
        fig_max(cum_eoy_total_deaths_per_million),
      cum_total_tests = 
        fig_max(cum_eoy_total_tests),
      cum_total_tests_per_thousand = 
        fig_max(cum_eoy_total_tests_per_thousand),
      cum_total_vaccinations = 
        fig_max(cum_eoy_total_vaccinations),
      cum_people_vaccinated = 
        fig_max(cum_eoy_people_vaccinated),
      cum_people_fully_vaccinated = 
        fig_max(cum_eoy_people_fully_vaccinated),
      cum_total_vaccinations_per_hundred = 
        fig_max(cum_eoy_total_vaccinations_per_hundred),
      cum_people_vaccinated_per_hundred = 
        fig_max(cum_eoy_people_vaccinated_per_hundred),
      cum_people_fully_vaccinated_per_hundred = 
        fig_max(cum_eoy_people_fully_vaccinated_per_hundred)    
      ) %>%
    ungroup() %>%
    arrange(country_standard, year)
    
########################################      
  
## Economist Intelligence Unit ##

    # The line below runs an R script that cleans the raw EIU data and 
    #   merges it as the EIU_democracy_index_clean.csv file
    source("data/raw_data/clean_eiu_raw.R", echo =  FALSE)

  import_EIU <- read_csv("data/EIU_democracy_index_clean.csv")
  
  df_eiu <- import_EIU %>%
    clean_names() %>%
    mutate(
      # Countries from 2020 are missing iso codes
      geo =
        ifelse(
          is.na(geo),
          countrycode(country, origin = 'country.name', destination = 'iso3c'),
          geo
          ),
      country_standard = countrycode(
        geo, 
        origin = "iso3c", 
        destination = "country.name"
        )) %>%
    # Adding "eiu" prefix to column names
    rename_with( 
    ~ paste("eiu", .x, sep = "_"), 
    overall_score:date) %>%
    select(country_standard, year, eiu_overall_score:eiu_regime_type, -eiu_rank, -eiu_rank_change)

########################################    
  
## Transparency International Corruption Perception Index
  
  import_CPI_Transparency_International <- read_excel("data/CPI_Transparency_International.xlsx")
  
  df_cpi <- import_CPI_Transparency_International %>%
    clean_names() %>%
    mutate(
      country_standard = countrycode(
        country_code,
        origin = "iso3c",
        destination = "country.name")) %>%
    select(country_standard, year, cpi_score)
  
########################################     
      
## Data from Open Government Partnership ##
  
  import_OGP_data <- read_excel("data/OGP_data.xlsx", 
    col_types = c("text", "numeric", "numeric", "numeric", "numeric"), 
    na = "NA")
  
  df_ogp <- import_OGP_data %>%
    clean_names() %>%
    rename(ogp_transparency_fisc_open = ogp_considerations_fo_transparency,
           ogp_participation_fisc_open = ogp_considerations_fo_participation) %>%
    mutate(
      country_standard = countrycode(
        country_code,
        origin = "iso3c",
        destination = "country.name"),
      ogp_trans_text = case_when(
        ogp_transparency_fisc_open == 1 ~ "Consider Action",
        ogp_transparency_fisc_open == 2 ~ "Implement for Results",
        ogp_transparency_fisc_open == 3 ~ "Share Innovation",
        TRUE ~ NA_character_),
      ogp_part_text = case_when(
        ogp_participation_fisc_open == 1 ~ "Consider Action",
        ogp_participation_fisc_open == 2 ~ "Implement for Results",
        ogp_participation_fisc_open == 3 ~ "Share Innovation",
        TRUE ~ NA_character_)      
      ) %>%
    filter(!is.na(country_standard)) %>%
    select(country_standard, everything(), -country_code) %>%
    arrange(country_standard, year)
  
  # Merging with large list of countries in previously saved merged_data_yr 
  # and assigning "zero" values to the ogp_participating variable for countries
  # not included in the imported OGP dataset
  df_ogp <- read_csv("data/merged_data_yr.csv") %>%
    select(country_standard, year) %>%
    distinct() %>%
    full_join(df_ogp, by = c("country_standard", "year")) %>%
    mutate(ogp_participating = ifelse(
      is.na(ogp_participating),
      0,
      ogp_participating
    )) %>%
    arrange(country_standard, year)

########################################    
  
## WGI indicators ##
  
  # Voice & Accountability and Control of Corruption
  
  import_Worldwide_Governance_Indicators_clean <- read_csv("data/Worldwide_Governance_Indicators_clean.csv")
  
  
  # Note: higher score is better for these indicators
  df_wgi <- import_Worldwide_Governance_Indicators_clean %>%
    clean_names() %>%
    rename(country = country_territory) %>%
    # The countrycodes package does not include Kosovo or the Netherlands Antilles
    filter(!country %in% c("Kosovo", "Netherlands Antilles (former)")) %>%
    mutate(
      country = case_when(
        code == "CIV" ~ "Ivory Coast",
        code == "STP" ~ "Sao Tome and Principe",
        code == "REU" ~ "Reunion",
        TRUE ~ country),
      iso_code = countrycode(country, origin = 'country.name', destination = 'iso3c'),        
      country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"
          )) %>%
    # Adding "wgi" prefix to indicators
    rename_with( 
      ~ paste("wgi", .x, sep = "_"),
      voice_and_accountability:control_of_corruption) %>%
    select(country_standard, year, everything(), -x1, -country, -iso_code)

  # Government Effectiveness
  #   Higher values = better
  import_wgi_gov_effective <- read_excel("data/wgi_gov_effective.xlsx", na = "NA")
  
  df_wgi_effect <- import_wgi_gov_effective %>%
    clean_names() %>%
    mutate(
      country_standard = countrycode(
        code,
        origin = "iso3c",
        destination = "country.name")) %>%
    filter(!is.na(country_standard)) %>%
    select(country_standard, everything(), -country_territory, -code) %>%
    pivot_longer(!country_standard, names_to = "year", values_to = "wgi_govt_effective") %>%
    mutate(
      year = as.numeric(
        str_remove(year, "x"))) %>%
    arrange(country_standard, year)
    
    
########################################    
  
## V-Dem indicators ##
  # There are three V-Dem data sets. We combine the first two.
  
  import_vdem_clean <- read_csv("data/vdem_clean.csv")
  
  df_vdem <- import_vdem_clean %>%
    clean_names() %>%
    # This data set has a very large range of years. Limiting to 2006 and later
    filter(year >= 2006) %>%
    filter(!country_name %in% c("Kosovo", "Somaliland", "Zanzibar")) %>%  
    mutate(
      iso_code = countrycode(country_name, origin = 'country.name', destination = 'iso3c'),        
      country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"
          )) %>%
    # Adding "vdem" prefix to indicators      
    rename_with( 
      ~ paste("vdem", .x, sep = "_"),
      v2x_libdem:v2x_cspart) %>%
    select(country_standard, year, everything(), -country_name, -iso_code)
  
  # Additional V-Dem indicators for accountability, transparency, and corruption
    # Note: Higher score is better for these indicators
  import_vdem_atc <- read_csv("data/Vdem_account_transp_corrupt.csv")
  
  df_vdem_atc <- import_vdem_atc %>%
    clean_names() %>%
    # This data set has a very large range of years. Limiting to 2006 and later
    filter(year >= 2006) %>%
    filter(!country_name %in% c("Kosovo", "Somaliland", "Zanzibar")) %>%  
    mutate(
      iso_code = countrycode(country_name, origin = 'country.name', destination = 'iso3c'),        
      country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"
          )) %>%
    # Adding "vdem" prefix to indicators      
    rename_with( 
      ~ paste("vdem", .x, sep = "_"),
      transparent_laws:public_sector_corruption) %>%
    select(country_standard, year, everything(), -country_name, -country_text_id)
  
  df_vdem <- df_vdem %>% full_join(df_vdem_atc, by = c("country_standard", "year"))
  
  # Data from V-Dem's "Pandemic Backsliding" Project
  import_pandem <- read_csv("data/PanDem_cs_V5.csv")
  
  df_pandem <- import_pandem  %>%
    clean_names() %>%
    mutate(
      iso_code = countrycode(country_name, origin = 'country.name', destination = 'iso3c'),        
      country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"
          )) %>%
    select(country_standard, pandem, panback) %>%
    distinct()
  
########################################    
  
## Freedom House indicators ##
  import_Freedom_house <- read_excel("data/Freedom_house.xlsx")
  
  # Note: the higher the freedom score, the better
  df_fh <- import_Freedom_house %>%
    clean_names() %>%
    select(-country_territory) %>%
    filter(!countries %in% 
             c('Abkhazia', 'Crimea', 'Eastern Donbas', 'Kosovo', 'Micronesia',
               'Nagorno-Karabakh', 'Somaliland', 'South Ossetia', 'Tibet',
               'Transnistria')) %>%
    # If I want to take out the line below, import sheet two from the excel file instead
    pivot_longer(!countries, names_to = "year", values_to = "fh_global_freedom_score") %>%
    mutate(
      iso_code = countrycode(countries, origin = 'country.name', destination = 'iso3c'),        
      country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"),
      year = as.numeric(str_remove(year, "x"))) %>%
    select(country_standard, year, fh_global_freedom_score) %>%
    arrange(country_standard, year)

########################################    
  
## WVS indicators ##
  
  # The data imported in the line below is too large to store on GitHub.
  # It can be stored locally and downloaded from this link: 
  #     https://www.worldvaluessurvey.org/WVSDocumentationWVL.jsp
  import_wvs <- readRDS("~/GitHub/policy_lab_ndi/data/WVS_TimeSeries_R_v1_6.rds")
  
  df_wvs <- import_wvs %>%
    select(S003, S020, E069_07, E069_11, E069_17, E069_64, E268) %>%
    mutate(
      country_standard = countrycode(
        S003, 
        origin = "iso3n", 
        destination = "country.name")
    ) %>%
    rename(
      year = S020,
      wvs_trust_parliament = E069_07,
      wvs_trust_gov = E069_11,
      wvs_trust_court = E069_17,
      wvs_trust_elect = E069_64,
      wvs_corruption = E268
    ) %>%
    select(country_standard, everything(), -S003) 

  
  # WVS data uses labels. The line below can be useful for seeing
  # the value-label association
  # val_labels(df_wvs)
  
  df_wvs <- df_wvs %>%
    mutate(
      across(year:wvs_corruption, ~as.numeric(.)),
      across(year:wvs_corruption, ~replace(., is.na(.), NA_integer_)),
        # WVS uses a counter-intuitive scoring system (higher number = worse)
        # The code below reverses this for variables measured from 1 to 4
      across(wvs_trust_parliament:wvs_trust_elect, ~5-.),
        # The code below reverses this for variables measured from 1 to 10)
      wvs_corruption = 11 - wvs_corruption) %>%
      group_by(country_standard, year) %>%
        # Creating averages by country and year
      summarise(across(wvs_trust_parliament:wvs_corruption, ~mean(.x, na.rm = TRUE)), .groups = "drop") %>%
        # Changing NaN to NA
      mutate(across(year:wvs_corruption, ~ case_when(!is.nan(.x) ~ .x))) %>%
      arrange(country_standard, year) %>%
    filter(year >= 2006)
      
########################################      
    
## Africa Integrity Indicators ##
  
  import_africa_integrity <- read_excel("data/Africa_Integrity_Indictors_CLEAN_22021.xlsx", na = "n/a")
  
  df_africa_int <- import_africa_integrity %>%
    clean_names()  %>% 
    select(
      country,
      year,
      in_practice_citizens_can_access_the_results_and_documents_associated_with_procurement_contracts_full_contract_proposals_execution_reports_financial_audits_etc,
      in_law_citizens_have_a_right_to_request_public_information_from_state_bodies,
      in_practice_citizen_requests_for_public_information_are_effective,
      in_practice_citizens_can_access_legislative_processes_and_documents,
      in_law_senior_officials_of_the_three_branches_of_government_including_heads_of_state_and_government_ministers_members_of_parliament_judges_etc_are_required_to_disclose_records_of_their_assets_and_disclosures_are_public,
      in_law_political_parties_are_required_to_regularly_disclose_private_donations,
      in_law_corruption_is_criminalized_as_a_specific_offense,
      in_practice_the_body_bodies_that_investigate_s_allegations_of_public_sector_corruption_is_are_effective,
      in_law_civil_servants_who_report_cases_of_corruption_are_protected_from_recrimination_or_other_negative_consequences,
      in_law_there_is_an_independent_body_bodies_mandated_to_receive_and_investigate_cases_of_alleged_public_sector_corruption
    )
  
  names(df_africa_int) <- names(df_africa_int) %>% 
    str_remove("^in_practice_") %>% 
    str_remove("^in_law_") %>% 
    str_trunc(32,  ellipsis = "")
    
  #names(df_africa_int) <- abbreviate(names(df_africa_int), minlength = 16)
  #names(df_africa_int) <- names(df_africa_int) %>% str_replace_all("\\_{2,}", "")
  names(df_africa_int) <- names(df_africa_int) %>% make.unique()
  
  df_africa_int <- df_africa_int %>%
    mutate(
      country = ifelse(
        country == "sundan",
        "sudan",
        country),
      iso_code = countrycode(country, origin = 'country.name', destination = 'iso3c'),
      country_standard = countrycode(
        iso_code, 
        origin = "iso3c", 
        destination = "country.name"
        )) %>%
    select(country_standard, year, everything(), -country) %>%    
    # Adding "afr_int" prefix to column names
    rename_with( 
    ~ paste("afr_int", .x, sep = "_"), 
    !(country_standard:year)) %>%
    filter(!is.na(year))
  
########################################    
  
## Public health expenditures as share of GDP   
  import_gdp_pub_health_expenditures <- read_csv("data/public-health-expenditure-share-GDP-OWID.csv")
  
  df_gdp_health_expend <- import_gdp_pub_health_expenditures %>%
    clean_names() %>%
    # This data set has a very large range of years. Limiting to 2006 and later    
    filter(year >= 2006) %>%
    rename(pub_health_exp_percent_gdp = public_expenditure_on_health_percent_gdp_owid_extrapolated_series) %>%
    mutate(country_standard = countrycode(
      code, 
      origin = "iso3c", 
      destination = "country.name")) %>%
    select(country_standard, year, pub_health_exp_percent_gdp, everything())

  attr(df_gdp_health_expend$pub_health_exp_percent_gdp, "label") <- "Public expenditure on health as a percent of GDP"
    
########################################    
  
##  Public health expenditures per capita ##
  
  import_percap_Public_Health_Expenditure <- read_csv("data/WB_Public_Health_Expenditure_v3.csv")
  
  df_percap_health_expend <- import_percap_Public_Health_Expenditure %>%
    clean_names() %>%
    # The data includes entries for "Arab World" as a country. Removing that.
    filter(country_code != "ARB") %>%
    mutate(country_standard = countrycode(
      country_code, 
      origin = "iso3c", 
      destination = "country.name")) %>%
    rename(percap_domestic_health_expenditure = domestic_health_expenditure) %>%
    select(country_standard, year, everything(), -country_name, -country_code)

########################################      
    
## GDP Data ##
  
  # We're using GDP as a control variable
  import_GDP_data <- read_excel("data/GDP_data.xlsx")
  
  df_gdp <- import_GDP_data %>%
    clean_names() %>%
    filter(!country_code %in% 
    c('ARB', 'CEB', 'CSS', 'EAP', 'EAR', 'EAS', 'ECA', 'ECS', 'EMU', 'EUU', 
    'FCS', 'HIC', 'HPC', 'IBD', 'IBT', 'IDA', 'IDB', 'IDX', 'INX', 'LAC', 
    'LCN', 'LDC', 'LIC', 'LMC', 'LMY', 'LTE', 'MEA', 'MIC', 'MNA', 'NAC', 
    'OED', 'OSS', 'PRE', 'PSS', 'PST', 'SAS', 'SSA', 'SSF', 'SST', 'TEA', 
    'TEC', 'TLA', 'TMN', 'TSA', 'TSS', 'UMC', 'WLD')) %>%
    mutate(country_standard = countrycode(
      country_code, 
      # Note that this uses WB as country code style, not iso3c
      origin = "wb", 
      destination = "country.name")) %>%
    filter(!is.na(country_standard)) %>%
    select(country_standard, year, gdp)
    
########################################    
  
## Gini Coefficient ##
  
  # We're using the Gini coefficient as a control variable
  import_Gini_coefficient_2020 <- read_csv("data/Gini_coefficient_2020.csv")
  
  df_gini <- import_Gini_coefficient_2020 %>%
    clean_names() %>%
      mutate(
        iso_code = countrycode(country, origin = 'country.name', destination = 'iso3c'),
        country_standard = countrycode(
          iso_code, 
          origin = "iso3c", 
          destination = "country.name"
          )) %>%
    rename(gini_2020 = gini_coefficient_2020_data) %>%
    select(country_standard, gini_2020)  
```


Merging datasets

```{r merging_data, include=FALSE}
  df_all <- df_covid_owid %>%
    full_join(df_eiu, by = c("country_standard", "year")) %>%
    full_join(df_cpi, by = c("country_standard", "year")) %>%
    full_join(df_ogp, by = c("country_standard", "year")) %>%  
    full_join(df_wgi, by = c("country_standard", "year")) %>% 
    full_join(df_wgi_effect, by = c("country_standard", "year")) %>%
    full_join(df_vdem, by = c("country_standard", "year")) %>% 
    full_join(df_pandem, by = "country_standard") %>%      
    full_join(df_fh, by = c("country_standard", "year")) %>%       
    full_join(df_gdp_health_expend, by = c("country_standard", "year")) %>%
    full_join(df_percap_health_expend, by = c("country_standard", "year")) %>%
    full_join(df_gdp, by = c("country_standard", "year")) %>%
    full_join(df_gini, by = "country_standard") %>%
    full_join(df_wvs, by = c("country_standard", "year")) %>%
    full_join(df_africa_int, by = c("country_standard", "year")) %>%
    select(
      country_standard, 
      year, 
      date,
      median_age:aged_65_older,
      gdp_per_capita,
      eiu_overall_score:eiu_regime_type,
      ogp_participation_fisc_open:ogp_participating,
      pub_health_exp_percent_gdp,
      everything(),
      -name_country_standard,
      -location,
      -code.x,
      -entity
      ) %>%
    mutate(post_covid = 
             ifelse(year >= 2020,
                    TRUE,
                    FALSE))

  # Looking at entries where ISO codes didn't match with a country
  df_no_country <- df_all %>% filter((is.na(country_standard)))
  
  # Removing entries with missing country_standard name
  df_all <- df_all %>% filter(!(is.na(country_standard)))
  
  # Limiting to the year 2006 and later
  df_all <- df_all %>% filter(year >= 2006)

  # Exporting df_all
  write_csv(df_all, "data/merged_data.csv")
  
  ## By year instead of date ##
  df_all_yr <- df_covid_owid_yr %>%
    full_join(df_eiu, by = c("country_standard", "year")) %>%
    full_join(df_cpi, by = c("country_standard", "year")) %>%
    full_join(df_ogp, by = c("country_standard", "year")) %>%  
    full_join(df_wgi, by = c("country_standard", "year"))  %>% 
    full_join(df_wgi_effect, by = c("country_standard", "year")) %>%
    full_join(df_vdem, by = c("country_standard", "year")) %>% 
    full_join(df_pandem, by = "country_standard") %>%      
    full_join(df_fh, by = c("country_standard", "year")) %>%       
    full_join(df_gdp_health_expend, by = c("country_standard", "year")) %>%
    full_join(df_percap_health_expend, by = c("country_standard", "year")) %>%
    full_join(df_gdp, by = c("country_standard", "year")) %>%
    full_join(df_gini, by = "country_standard") %>%
    full_join(df_wvs, by = c("country_standard", "year")) %>%    
    full_join(df_africa_int, by = c("country_standard", "year")) %>%
    select(
      country_standard, 
      year, 
      median_age:aged_65_older,
      gdp_per_capita,
      eiu_overall_score:eiu_regime_type,
      ogp_participation_fisc_open:ogp_participating,
      pub_health_exp_percent_gdp,
      everything(),
      -code.x,
      -entity
      ) %>%
    mutate(post_covid = 
             ifelse(year >= 2020,
                    TRUE,
                    FALSE))
  
    # Limiting to the year 2006 and later
          # Some data (including WGI and Gini index) go back further
    df_all_yr <- df_all_yr %>% filter(year >= 2006)
    
    # Looking specifically at 2020
    df_all_yr_2020 <- df_all_yr %>% filter(year == 2020)
  
    # Exporting df_all_yr
    write_csv(df_all_yr, "data/merged_data_yr.csv")
    write_csv(df_all_yr_2020, "data/merged_data_yr_2020.csv")
  
```

When reviewing the data, a helpful link for issues: https://github.com/ropensci/skimr/issues/606

```{r controls, echo=TRUE}

# Controls for COVID outcomes
df_controls <- df_all_yr %>%
  arrange(country_standard, year) %>%
  group_by(country_standard) %>%
  # These variables don't have values in 2020. Filling in from most recent year
  fill(
    c(gdp, pub_health_exp_percent_gdp, percap_domestic_health_expenditure)) %>%
  filter(year==2020) %>%
  select(
    country_standard, 
    gdp, 
    pub_health_exp_percent_gdp, 
    percap_domestic_health_expenditure)
  
df_controls <- df_all_yr_2020 %>%
  select(
    country_standard, gdp_per_capita, gini_2020, median_age, aged_65_older) %>%
  full_join(df_controls, by = "country_standard") %>% 
  select(
    country_standard, gdp, gdp_per_capita, gini_2020, 
        # we discussed using "public health expenditure as a proportion of GDP"
        # as an indicator, but it seemed very similar to the next indicator
        # below, which is "public health expenditure per capita"
    #pub_health_exp_percent_gdp, 
    percap_domestic_health_expenditure, 
    median_age, aged_65_older)

write_csv(df_controls, "data/controls.csv")

```


# Creating an index for COVID-19 health factors

(add that we are logging)

Our COVID-19 index comes from country-level measures starting from January 1, 2020. The measures are used in the following equation: (1 / COVID-19 cases per million) * (1 / COVID-19 deaths per million) * (total COVID-19 tests per thousand)

The intuition is that countries will have a higher index score if they have fewer cases, fewer deaths, and more tests. The index is scaled from 0 (worst) to 1 (best).

We decided on this index after testing it among six considered models. We regressed each index on our list of control variables and compared the F-statistic of each model. The chosen model had the second highest F-Statistic, but was chosen because a review of the country rankings of the model with the highest F-statistic revealed it to be a poor index.

To see the code for the process above, see reference_dode/covid_index_select.r

For countries that were missing data on COVID-19 tests, they are assigned a score of "1" on the scale of 1 to 10 used for countries' testing rates.

```{r covid_index, echo=TRUE}
df_covid_index <- df_all_yr %>%
  select(
    country_standard, 
    cum_total_cases_per_million, 
    cum_total_deaths_per_million,
    cum_total_tests_per_thousand) %>%
  filter(
    if_any(
      cum_total_cases_per_million:cum_total_deaths_per_million, 
      ~ !is.na(.))) %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
        # Use a scale of 1 - 10 to avoid having "0" in denominator
        # Not that we use a natural log on the three lines below
    stand_total_cases_per_million  = rescale(log(cum_total_cases_per_million), to = c(1, 10)),
    stand_total_deaths_per_million = rescale(log(cum_total_deaths_per_million), to = c(1, 10)),
    stand_total_tests_per_thousand = rescale(log(cum_total_tests_per_thousand), to = c(1, 10)),
    stand_total_tests_per_thousand_no_NA = ifelse(
      is.na(stand_total_tests_per_thousand), 
      1, 
      stand_total_tests_per_thousand),
    covid_index = rescale(
      (1/stand_total_cases_per_million) +
      (1/stand_total_deaths_per_million) +
      stand_total_tests_per_thousand_no_NA)
    ) %>%
  select(country_standard, covid_index, everything())

# Reviewing distribution of the data
histogram(df_covid_index$stand_total_cases_per_million)
histogram(df_covid_index$stand_total_deaths_per_million)
histogram(df_covid_index$stand_total_tests_per_thousand_no_NA)
histogram(df_covid_index$covid_index)

# RUnning a regression of control variables on COVID-19 index
covid_index_mod_test <- df_covid_index %>% 
  select(country_standard, covid_index) %>%
  full_join(df_controls, by = "country_standard") %>%
  select(-country_standard)

  lm(covid_index ~ ., data = covid_index_mod_test) %>% summary()

write_csv(df_covid_index, "data/covid-19_index.csv")

```

# Transparency Index

```{r}
# Since Freedom House data only goes back to 2012, 
#   the index only goes back to 2012

df_transparency_indicators <- df_all_yr %>%
  select(
    country_standard,
    year,
    fh_global_freedom_score,
    wgi_voice_and_accountability
  ) 

df_transparency_index <- df_transparency_indicators %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
    non_na_sum = rowSums(!is.na(across(fh_global_freedom_score:wgi_voice_and_accountability))),
    across(
      fh_global_freedom_score:wgi_voice_and_accountability,
      ~rescale(.)),
    numerator = rowSums(across(fh_global_freedom_score:wgi_voice_and_accountability), na.rm=TRUE),
    transparency_index = rescale(numerator / non_na_sum),
    incomplete_trans_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE
    )) %>%
  select(country_standard, year, transparency_index, everything()) %>%
  arrange(country_standard, year) %>%
  filter(year >= 2012 & year <= 2019)

skim(df_transparency_index)
histogram(df_transparency_index$transparency_index)
```
# Budget transparency index

```{r}
# I assign "0" to NA values (assuming that means countries not participating)

df_budget_transparency_index <- df_all_yr %>%
  select(
    country_standard,
    year,
    ogp_transparency_fisc_open) %>%
  filter(!is.na(country_standard)) %>%
  distinct() %>%
  mutate(
    ogp_transparency_fisc_open = ifelse(
      is.na(ogp_transparency_fisc_open),
      0,
      ogp_transparency_fisc_open),
    incomplete_bdgt_trans_index = if_else(
      ogp_transparency_fisc_open==0,
      TRUE,
      FALSE),
    budget_transparency_index = rescale(ogp_transparency_fisc_open)) %>%
  select(country_standard, year, budget_transparency_index, everything()) %>%
  arrange(country_standard, year)

skim(df_budget_transparency_index)
histogram(df_budget_transparency_index$budget_transparency_index)
```

# Accountability Index

```{r}

#   The most recent data in the index is from 2019, but to make it

df_accountability_indicators <- df_all_yr %>%
  select(
    country_standard,
    year,
    vdem_diagonal_account,
    vdem_vertical_account,
    vdem_horizontal_account
  ) 

df_accountability_index <- df_accountability_indicators %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
    non_na_sum = rowSums(!is.na(across(vdem_diagonal_account:vdem_horizontal_account))),
    across(
      vdem_diagonal_account:vdem_horizontal_account,
      ~rescale(.)),
    numerator = rowSums(across(vdem_diagonal_account:vdem_horizontal_account), na.rm=TRUE),
    accountability_index = rescale(numerator / non_na_sum),
    incomplete_acnt_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE)) %>%
  select(country_standard, year, accountability_index, everything()) %>%
  arrange(country_standard, year)

skim(df_accountability_index)
histogram(df_accountability_index$accountability_index)
```


# Trust index

```{r}
# What should we do about the many missing WVS values?
#   Many of the wvs_trust_values are missing
#   The current index only includes 83 countries
#   This index has code to use "fill" between missing dates. 
# Q: Should we use fill?

# NDI seemed interested in "Democratic Political Culture" (This seems to have more to do with the perception of democracy and not trust of government)
#   Leaving out for now

#### Looking at countries, results are not what I'd expect....

df_trust_indicators <- df_all_yr %>%
  select(
    country_standard,
    year,
    wvs_trust_parliament,
    #eiu_pol_culture,
    wvs_trust_gov,
    wvs_trust_court,
    wvs_trust_elect)

df_trust_index <- df_trust_indicators %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
    non_na_sum = rowSums(!is.na(across(wvs_trust_parliament:wvs_trust_elect))),
    across(
      wvs_trust_parliament:wvs_trust_elect,
      ~rescale(.)),
    numerator = rowSums(across(wvs_trust_parliament:wvs_trust_elect), na.rm=TRUE),
    trust_index = rescale(numerator / non_na_sum),
    incomplete_trust_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE)) %>%    
  select(country_standard, year, trust_index, everything()) %>%
  arrange(country_standard, year)

countries_in_trust_index <- df_trust_index %>% filter(!is.na(trust_index)) %>% select(country_standard, year) %>% distinct() %>% tibble()

skim(df_trust_index)
histogram(df_trust_index$trust_index)
```

# Corruption index

```{r}

# We have option to include WVS corruption indicator, but it is not very comprehensive

# CPI score only starts in 2012
df_corruption_indicators <- df_all_yr %>%
  select(
    country_standard,
    year,
    wgi_control_of_corruption,
    #wvs_corruption,
    cpi_score) %>%
  arrange(country_standard, year)

df_corruption_index <- df_corruption_indicators %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  mutate(
    non_na_sum = rowSums(!is.na(across(wgi_control_of_corruption:cpi_score))),
    across(
      wgi_control_of_corruption:cpi_score,
      ~rescale(.)),
    numerator = rowSums(across(wgi_control_of_corruption:cpi_score), na.rm=TRUE),
    corruption_index = rescale(-(numerator / non_na_sum)),
    incomplete_corrupt_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE)) %>%    
  select(country_standard, year, corruption_index, everything()) %>%
  arrange(country_standard, year) %>%
  filter(year <= 2019)

skim(df_corruption_index)
histogram(df_corruption_index$corruption_index)
```
# Effectiveness Index

```{r}
# I re-use 2019 wgi numbers in 2020.

df_effectiveness_indicators <- df_all_yr %>%
  select(
    country_standard,
    year,
    wgi_govt_effective,
    eiu_gov_func)

df_effectiveness_index <- df_effectiveness_indicators %>%
  filter(!is.na(country_standard)) %>%  
  distinct() %>%
  #arrange(country_standard, year) %>%
  # mutate(
  #   wgi_govt_effective = ifelse(
  #     year==2020,
  #     lag(wgi_govt_effective),
  #     wgi_govt_effective)) %>%
  mutate(
    non_na_sum = rowSums(!is.na(across(wgi_govt_effective:eiu_gov_func))),
    across(
      wgi_govt_effective:eiu_gov_func,
      ~rescale(.)),
    numerator = rowSums(across(wgi_govt_effective:eiu_gov_func), na.rm=TRUE),
    effectiveness_index = rescale(numerator / non_na_sum),
    incomplete_effect_index = if_else(
      non_na_sum < max(non_na_sum),
      TRUE,
      FALSE)) %>%
  select(country_standard, year, effectiveness_index, everything()) %>%
  arrange(country_standard, year) %>%
  filter(year <= 2019)

skim(df_effectiveness_index)
histogram(df_effectiveness_index$effectiveness_index)

```

# Budget particpation index

```{r}
# I assign "0" to NA values (assuming that means countries not participating)

df_budget_particpation_index <- df_all_yr %>%
  select(
    country_standard,
    year,
    ogp_participation_fisc_open) %>%
  filter(!is.na(country_standard)) %>%
  distinct() %>%
  mutate(
    ogp_participation_fisc_open = ifelse(
      is.na(ogp_participation_fisc_open),
      0,
      ogp_participation_fisc_open),
    incomplete_bdgt_part_index = if_else(
      ogp_participation_fisc_open==0,
      TRUE,
      FALSE),
    budget_participation_index = rescale(ogp_participation_fisc_open)) %>%
  select(country_standard, year, budget_participation_index, everything()) %>%
  arrange(country_standard, year)

skim(df_budget_particpation_index)
histogram(df_budget_particpation_index$budget_participation_index)
```

# Pandemic Violation Index

```{r}
df_pandem_dem_violation_index <- df_all_yr %>%
  select(
    country_standard,
    pandem
  ) %>%
  filter(!is.na(country_standard)) %>%
  distinct() %>%
  mutate(
    incomplete_dem_vio_index = if_else(
      is.na(pandem),
      TRUE,
      FALSE),    
    pandemic_dem_violation_index = rescale(pandem)) %>%
  select(country_standard, pandemic_dem_violation_index, everything()) %>%
  arrange(country_standard)

skim(df_pandem_dem_violation_index)
histogram(df_pandem_dem_violation_index$pandemic_dem_violation_index)

```

# Combining Indices and Controls

```{r}

df_indices_controls <- df_transparency_index %>%
  select(country_standard, year, transparency_index, incomplete_trans_index) %>%
  full_join(df_budget_transparency_index[ , c("country_standard", "year", "budget_transparency_index", "incomplete_bdgt_trans_index")], by = c("country_standard", "year")) %>%
  full_join(df_accountability_index[ , c("country_standard", "year", "accountability_index", "incomplete_acnt_index")], by = c("country_standard", "year")) %>%
  full_join(df_trust_index[ , c("country_standard", "year", "trust_index", "incomplete_trust_index")], by = c("country_standard", "year")) %>%
  full_join(df_corruption_index[ , c("country_standard", "year", "corruption_index", "incomplete_corrupt_index")], by = c("country_standard", "year")) %>%
  full_join(df_effectiveness_index[ , c("country_standard", "year", "effectiveness_index", "incomplete_effect_index")], by = c("country_standard", "year")) %>%
  full_join(df_budget_particpation_index[ , c("country_standard", "year", "budget_participation_index", "incomplete_bdgt_part_index")], by = c("country_standard", "year")) %>%
  full_join(df_pandem_dem_violation_index[ , c("country_standard", "pandemic_dem_violation_index", "incomplete_dem_vio_index")], by = "country_standard") %>%
  full_join(df_covid_index[ , c("country_standard", "covid_index")], by = "country_standard") %>%
  full_join(df_controls, by = "country_standard") %>%
  filter(!is.na(country_standard)) %>%
  arrange(country_standard, year)

df_indices_controls_incomplete <- df_indices_controls %>%
  select(country_standard, year, starts_with('incomplete')) %>%
  replace(is.na(.), TRUE) %>%
  summarise(across(where(is.logical), sum))

df_indices_controls <- df_indices_controls %>% 
  select(country_standard, year, everything(), -starts_with('incomplete')) %>%
  mutate(across(where(is.numeric), ~ case_when(!is.nan(.x) ~ .x)))

skim(df_indices_controls)

write_csv(df_indices_controls, "data/indices_and_controls.csv")
```



You can do python code, like in example chunk below.

```{python include=FALSE}
print("hello world")

import pandas as pd
import numpy as np
import seaborn as sns
import statsmodels.api as sm
import statsmodels.formula.api as smf
get_ipython().system('pip install linearmodels')
from linearmodels import PanelOLS
import statsmodels.formula.api as smf
from statsmodels.base.covtype import get_robustcov_results


# In[2]:


path = r'/Users/katiacordoba/Documents/GitHub/policy_lab_ndi/data/indices_and_controls.csv'
ndi_df = pd.read_csv(path)


# In[3]:


ndi_df


# In[4]:


#Replace NaN with mean of column 
column_means = ndi_df.mean()
ndi_df = ndi_df.fillna(column_means)


# In[5]:


ndi_df


# In[6]:


#Drop last 15 rows with NA values in country_standard
ndi_df = ndi_df.dropna(subset=['country_standard'])


# In[7]:


ndi_df


# In[8]:


pairplot = sns.pairplot(data = ndi_df)


# In[9]:


#pairplot.savefig("Indices, transparency and controls pairplot.png")


# In[10]:


reg_corruption = smf.ols('corruption_index ~ transparency_index + gdp + gdp_per_capita + gini_2020 + C(country_standard)', ndi_df).fit(cov_type='cluster', cov_kwds={'groups': ndi_df['country_standard']})


# In[11]:


reg_corruption.summary()


# In[12]:


reg_trust = smf.ols('trust_index ~ transparency_index + gdp + gdp_per_capita + gini_2020 + C(country_standard)', ndi_df).fit(cov_type='cluster', cov_kwds={'groups': ndi_df['country_standard']})


# In[13]:


reg_trust.summary()


# In[14]:


reg_effectiveness = smf.ols('effectiveness_index ~ transparency_index + gdp + gdp_per_capita + gini_2020 + C(country_standard)', ndi_df).fit(cov_type='cluster', cov_kwds={'groups': ndi_df['country_standard']})


# In[15]:


reg_effectiveness.summary()


# In[16]:


reg_bugetparticipation = smf.ols('budget_participation_index ~ transparency_index + gdp + gdp_per_capita + gini_2020 + C(country_standard)', ndi_df).fit(cov_type='cluster', cov_kwds={'groups': ndi_df['country_standard']})


# In[17]:


reg_bugetparticipation.summary()


# In[18]:


df_2020 = ndi_df.loc[ndi_df['year'] == 2020]


# In[19]:


df_2020


# In[20]:


#COVID outcomes model
reg_covid = smf.ols('covid_index ~ transparency_index + gdp + gdp_per_capita + gini_2020 + percap_domestic_health_expenditure + median_age + aged_65_older', df_2020).fit()


# In[21]:


reg_covid.summary()


# In[22]:


#Fixed effects or not, only 2020? 
#reg_pandemic_violations = smf.ols('pandemic_dem_violation_index ~ transparency_index + gdp + gdp_per_capita + gini_2020 + percap_domestic_health_expenditure + median_age + aged_65_older + C(country_standard)', ndi_df).fit(cov_type='cluster', cov_kwds={'groups': ndi_df['country_standard']})


# In[23]:


reg_pandemic_violations = smf.ols('pandemic_dem_violation_index ~ transparency_index + gdp + gdp_per_capita + gini_2020 + percap_domestic_health_expenditure + median_age + aged_65_older', df_2020).fit()


# In[24]:


reg_pandemic_violations.summary()

```

## Notes to self:

We don't have 2020 GDP data

There are about 20 countries missing Gini index data

From OWID Covid, look at "stringeny_index"

Is it an issue that controls don't change by year?

should we make a "most recent" that just pulls the most recent value availalbe for each



freedom house includes 2020 data? I don't see it right now


Additional ideas for controls:

-   df_covid_owid

    -   "population_density"

    -   "gdp_per_capita"

    -   "extreme_poverty"

    -   "cardiovasc_death_rate"

    -   "diabetes_prevalence"

    -   "female_smokers"

    -   "male_smokers"

    -   "handwashing_facilities"

    -   "hospital_beds_per_thousand"

    -   "life_expectancy"

    -   "human_development_index"

## Resources:

-   

## Citations:

This project uses the countrycode R package

Arel-Bundock, Vincent, Nils Enevoldsen, and CJ Yetman, (2018). countrycode: An R package to convert country names and country codes. Journal of Open Source Software, 3(28), 848, <https://doi.org/10.21105/joss.00848>
